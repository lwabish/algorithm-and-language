from typing import List
from lwabish.common import print_used_time
tcs = [
    # ("babad",),
    # ("a",),
    # ("ac",),
    # ("cbbd",),
    # ("pabbbbaq",),
    # ("bb",),
    # ("abcba",),
    # ("xaabacxcabaaxcabaax",),
    # ("tattarrattat",),
    # ("arra",),
    # ("aaabaaaa",),
    ("1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",),
]


class Solution:

    @print_used_time(show_params=False)
    def longestPalindrome(self, s: str) -> str:
        """
        最长回文子串
        中心扩散法
        会超时
        """
        result = ""
        for i in range(2*len(s)-1):
            l = i//2
            if i % 2 == 0:
                r = l
            else:
                r = l+1
            # 切出初始字符串
            middle_str = s[l:r+1]
            # 先看初始中心点是否满足回文，不满足回文直接跳过
            if not self.validate(middle_str):
                continue
            # 是回文的前提下，是否最长
            elif len(middle_str) > len(result):
                result = middle_str
            # 开始沿初始字符串往两端扩展
            while l > 0 or r < len(s)-1:
                if l > 0:
                    l -= 1
                if r < len(s)-1:
                    r += 1
                middle_str = s[l:r+1]
                if not self.validate(middle_str):
                    break
                elif len(middle_str) > len(result):
                    result = middle_str

        return result

    def validate(self, s: str) -> bool:
        if s == s[::-1]:
            return True
        return False


if __name__ == '__main__':
    solution = Solution()
    for tc in tcs:
        print(solution.longestPalindrome(*tc))
