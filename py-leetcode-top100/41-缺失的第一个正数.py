from typing import List
tcs = [
    ([3, 4, -1, 1, 9, -5],),
]


# 难点：O1空间复杂度
# 很难想到的思路：利用如下事实：长度为N时，答案只能是[1,N+1]中的某一个数
# 用改数组内部元素的方法代替哈希，标记状态，且非常巧妙地在修改过程中不丢失原数组的关键信息
# 小刀剌屁股，这题应该不会出现在面试里
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)

        # 数组里有三类数：负数，[1,N]中的数,[N+1, ...]中的数
        # 只有[1,N]中的数可能影响结果
        # 我们需要二元标记，但是现在有三种状态，所以需要把两种没用的状态合并，所以我们把无效的数都改成N+1
        # 这里为什么不能反过来，把[N+1, ...]改成负数：因为后面我们需要用到绝对值，而[-N, -1]中的负数会影响绝对值，干扰结果，所以必须把负数先消灭掉
        # 这样只有两类数了：[1,N] 和N+1
        for i in range(n):
            if nums[i] <= 0:
                nums[i] = n + 1

        # 这时只有[1,N]中和n+1两类数了，我们需要标记一下[1,N]中的数哪些出现过
        # 比如长度为4的数组出现了3这个数字，那么我们需要标记一下3出现过
        # 标记的具体方法是把数组中对应位置的数置为负数，表示这个索引对应的数已经出现过了
        # 但是这题最秒的地方在于，我们标记的过程不能影响数组中有用的信息，因为我们要改原数组
        # 唯一的修改方法就是取反，因为这样后面我们用绝对值还能找到索引信息
        for i in range(n):
            num = abs(nums[i])
            if num <= n:
                nums[num - 1] = -abs(nums[num - 1])

        # 那么最后剩下的没有标记成负数的位置对应的索引就是结果了
        # 本质上是用数组的索引代替了哈希，实现空间复杂度的优化
        for k in range(n):
            if nums[k] > 0:
                return k+1
        return n+1


if __name__ == '__main__':
    solution = Solution()
    for tc in tcs:
        print(solution.firstMissingPositive(*tc))
